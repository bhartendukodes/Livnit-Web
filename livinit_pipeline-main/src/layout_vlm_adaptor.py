import json
import os
import re
import subprocess
from typing import Any, Dict, Optional


def run_layoutvlm_pipeline(
    scene_json_in: str,
    layoutvlm_root: str,
    save_dir: str,
    openai_model: Optional[str] = None,
    MAX_ATTEMPTS: int = 3,
) -> str:
    """
    Full callable function to run LayoutVLM from within your main pipeline.

    Steps:
    1. Reads the scene JSON generated by your main.py.
    2. Normalizes categories, keys, and descriptions for LayoutVLM compatibility.
    3. Validates that all assets exist in LayoutVLM/objaverse_processed/.
    4. Calls LayoutVLM/main.py to generate layout.json.
    5. Returns path to the produced layout.json.

    Example:
        layout_json = run_layoutvlm_pipeline(
            scene_json_in="test_vlm/codes/outputs/testing_scene_data_1.json",
            layoutvlm_root="/test_vlm/LayoutVLM",
            save_dir="test_vlm/LayoutVLM/runs/run_001",
            openai_model="gpt-5"
        )
    """

    # ------------------------------- #
    # Internal helpers
    # ------------------------------- #

    ALIAS_MAP = {
        "floor_lamps": "floor_lamp",
        "table_lamps": "table_lamp",
        "accent_chairs": "accent_chair",
        "chairs": "chair",
        "sofas": "sofa",
        "couches": "sofa",
        "rugs": "rug",
        "tv_stands": "tv_stand",
        "storage_units": "storage_unit",
        "book_shelves": "book_shelf",
        "plants": "plant",
        "decor_items": "decor",
        "side_tables": "side_table",
        "ottomans": "ottoman",
        "dinnings": "dining_table",
        "dining": "dining_table",
    }

    def _run_subprocess(
        cmd: list[str], cwd: Optional[str] = None, env: Optional[dict] = None
    ):
        proc = subprocess.run(
            cmd,
            cwd=cwd,
            env=env or os.environ.copy(),
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            check=False,
        )
        return proc.returncode, proc.stdout, proc.stderr

    def _sanitize_description(text: Any) -> str:
        s = str(text if text is not None else "")
        s = s.replace("\r", " ").replace("\n", " ").replace("/", " ")
        s = (
            s.replace('"', " ")
            .replace("'", " ")
            .replace("‘", " ")
            .replace("’", " ")
            .replace("“", " ")
            .replace("”", " ")
        )
        s = re.sub(r"\s{2,}", " ", s).strip()
        if len(s) > 300:
            s = s[:297] + "..."
        return s

    def _normalize_category(cat: str) -> str:
        cat_l = (cat or "").lower().strip()
        return ALIAS_MAP.get(cat_l, cat_l)

    def _normalize_assets(
        assets: Dict[str, Dict[str, Any]]
    ) -> Dict[str, Dict[str, Any]]:
        fixed: Dict[str, Dict[str, Any]] = {}
        for key, val in (assets or {}).items():
            val = dict(val or {})
            cat_new = _normalize_category(val.get("category", ""))
            val["category"] = cat_new
            val["description"] = _sanitize_description(val.get("description", cat_new))
            if "placements" not in val:
                val["placements"] = [
                    {
                        "position": [0.0, 0.0, 0.0],
                        "rotation": [0.0, 0.0, 0.0],
                        "optimize": 1,
                    }
                ]
            idx = 0
            m = re.search(r"-([0-9]+)$", key)
            if m:
                idx = int(m.group(1))
            new_key = f"{cat_new}-{idx}"
            fixed[new_key] = val
        return fixed

    def _unwrap_scene(d: Dict[str, Any]) -> Dict[str, Any]:
        if isinstance(d, dict) and "scene" in d and isinstance(d["scene"], dict):
            return d["scene"]
        return d

    def _prepare_scene(scene_json_in: str) -> str:
        with open(scene_json_in, "r", encoding="utf-8") as f:
            data = json.load(f)
        scene = _unwrap_scene(data)
        scene = dict(scene)
        scene["assets"] = _normalize_assets(scene.get("assets", {}))
        with open(scene_json_in, "w", encoding="utf-8") as f:
            json.dump(scene, f, indent=2)
        print(f"[OK] scene.json prepared → {scene_json_in}")
        return scene_json_in

    def _validate_scene(scene_path: str) -> bool:
        try:
            with open(scene_path, "r", encoding="utf-8") as f:
                scene = json.load(f)
            assets = scene.get("assets", {})
            if not assets:
                print("[ERR] No assets in scene.json")
                return False
            print(f"[OK] scene.json has {len(assets)} assets")
            return True
        except Exception as e:
            print(f"[ERR] Failed to read/validate scene.json: {e}")
            return False

    def _run_layoutvlm(scene_json_path: str) -> str:
        layoutvlm_main = os.path.join(layoutvlm_root, "main.py")
        asset_dir = os.path.join("assets", "objaverse_processed")
        if not os.path.exists(layoutvlm_main):
            raise FileNotFoundError(f"LayoutVLM main.py not found at {layoutvlm_main}")
        if not os.path.isdir(asset_dir):
            raise FileNotFoundError(f"Expected asset_dir not found: {asset_dir}")
        if not _validate_scene(scene_json_path):
            raise ValueError("Scene JSON validation failed")

        os.makedirs(save_dir, exist_ok=True)
        env = os.environ.copy()
        if openai_model:
            env["OPENAI_MODEL"] = openai_model

        cmd = [
            "python",
            layoutvlm_main,
            "--scene_json_file",
            scene_json_path,
            "--save_dir",
            os.path.abspath(save_dir),
            "--asset_dir",
            os.path.abspath(asset_dir),
            "--openai_api_key",
            env.get("OPENAI_API_KEY", ""),
        ]

        rc, out, err = _run_subprocess(cmd, env=env)
        if out.strip():
            print("---- LayoutVLM stdout ----")
            print(out)
        if err.strip():
            print("---- LayoutVLM stderr ----")
            print(err)
        if rc != 0:
            raise RuntimeError("LayoutVLM run failed")

        layout_json = os.path.join(save_dir, "layout.json")
        if not os.path.exists(layout_json):
            raise FileNotFoundError(f"layout.json not found in {save_dir}")
        print(f"[OK] LayoutVLM completed → {layout_json}")
        return layout_json

    # ------------------------------- #
    # Main Execution
    # ------------------------------- #
    for attempt_idx in range(MAX_ATTEMPTS):
        try:
            scene_json_clean = _prepare_scene(scene_json_in)
            layout_json_path = _run_layoutvlm(scene_json_clean)
            return layout_json_path
        except Exception as e:
            print(f"[WARN] Attempt {attempt_idx + 1} failed: {e}")
